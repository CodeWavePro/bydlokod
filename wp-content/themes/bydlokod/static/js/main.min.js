(function (factory) {
  typeof define === 'function' && define.amd ? define('main', factory) :
  factory();
}((function () { 'use strict';

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  } // Older browsers don't support event options, feature detect it.
  // Adopted and modified solution from Bohdan Didukh (2017)
  // https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi


  var hasPassiveEvents = false;

  if (typeof window !== 'undefined') {
    var passiveTestOptions = {
      get passive() {
        hasPassiveEvents = true;
        return undefined;
      }

    };
    window.addEventListener('testPassive', null, passiveTestOptions);
    window.removeEventListener('testPassive', null, passiveTestOptions);
  }

  var isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);
  var locks = [];
  var documentListenerAdded = false;
  var initialClientY = -1;
  var previousBodyOverflowSetting = void 0;
  var previousBodyPaddingRight = void 0; // returns true if `el` should be allowed to receive touchmove events.

  var allowTouchMove = function allowTouchMove(el) {
    return locks.some(function (lock) {
      if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
        return true;
      }

      return false;
    });
  };

  var preventDefault = function preventDefault(rawEvent) {
    var e = rawEvent || window.event; // For the case whereby consumers adds a touchmove event listener to document.
    // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
    // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
    // the touchmove event on document will break.

    if (allowTouchMove(e.target)) {
      return true;
    } // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).


    if (e.touches.length > 1) return true;
    if (e.preventDefault) e.preventDefault();
    return false;
  };

  var setOverflowHidden = function setOverflowHidden(options) {
    // If previousBodyPaddingRight is already set, don't set it again.
    if (previousBodyPaddingRight === undefined) {
      var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;

      var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;

      if (_reserveScrollBarGap && scrollBarGap > 0) {
        previousBodyPaddingRight = document.body.style.paddingRight;
        document.body.style.paddingRight = scrollBarGap + 'px';
      }
    } // If previousBodyOverflowSetting is already set, don't set it again.


    if (previousBodyOverflowSetting === undefined) {
      previousBodyOverflowSetting = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
    }
  };

  var restoreOverflowSetting = function restoreOverflowSetting() {
    if (previousBodyPaddingRight !== undefined) {
      document.body.style.paddingRight = previousBodyPaddingRight; // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
      // can be set again.

      previousBodyPaddingRight = undefined;
    }

    if (previousBodyOverflowSetting !== undefined) {
      document.body.style.overflow = previousBodyOverflowSetting; // Restore previousBodyOverflowSetting to undefined
      // so setOverflowHidden knows it can be set again.

      previousBodyOverflowSetting = undefined;
    }
  }; // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions


  var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
    return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
  };

  var handleScroll = function handleScroll(event, targetElement) {
    var clientY = event.targetTouches[0].clientY - initialClientY;

    if (allowTouchMove(event.target)) {
      return false;
    }

    if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
      // element is at the top of its scroll.
      return preventDefault(event);
    }

    if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
      // element is at the bottom of its scroll.
      return preventDefault(event);
    }

    event.stopPropagation();
    return true;
  };

  var disableBodyScroll = function disableBodyScroll(targetElement, options) {
    // targetElement must be provided
    if (!targetElement) {
      // eslint-disable-next-line no-console
      console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');
      return;
    } // disableBodyScroll must not have been called on this targetElement before


    if (locks.some(function (lock) {
      return lock.targetElement === targetElement;
    })) {
      return;
    }

    var lock = {
      targetElement: targetElement,
      options: options || {}
    };
    locks = [].concat(_toConsumableArray(locks), [lock]);

    if (isIosDevice) {
      targetElement.ontouchstart = function (event) {
        if (event.targetTouches.length === 1) {
          // detect single touch.
          initialClientY = event.targetTouches[0].clientY;
        }
      };

      targetElement.ontouchmove = function (event) {
        if (event.targetTouches.length === 1) {
          // detect single touch.
          handleScroll(event, targetElement);
        }
      };

      if (!documentListenerAdded) {
        document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? {
          passive: false
        } : undefined);
        documentListenerAdded = true;
      }
    } else {
      setOverflowHidden(options);
    }
  };
  var enableBodyScroll = function enableBodyScroll(targetElement) {
    if (!targetElement) {
      // eslint-disable-next-line no-console
      console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');
      return;
    }

    locks = locks.filter(function (lock) {
      return lock.targetElement !== targetElement;
    });

    if (isIosDevice) {
      targetElement.ontouchstart = null;
      targetElement.ontouchmove = null;

      if (documentListenerAdded && locks.length === 0) {
        document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? {
          passive: false
        } : undefined);
        documentListenerAdded = false;
      }
    } else if (!locks.length) {
      restoreOverflowSetting();
    }
  };

  let targetElement;
  /**
   * Render SVG code from images (<img /> tags).
   *
   * @param {DOMElement}	wrapper		DOM element, inside which need to render svgs.
   * @param {String}		imgSelector	Specific selector for <img /> tag to render SVG.
   */

  const renderSVGs = (wrapper, imgSelector = '') => {
    if (!wrapper) return; // Get images with specific selector only OR all images.

    const selector = imgSelector ? `img${imgSelector}` : 'img',
          images = wrapper.querySelectorAll(selector),
          svgs = []; // If there are no images - exit.

    if (!images.length) return; // Get only svg images to svgs array.

    images.forEach(img => {
      let src = img.src,
          extension = src.slice(-4);
      if (extension === '.svg') svgs.push(img);
    }); // If there are no svgs - exit.

    if (!svgs.length) return;
    const parser = new DOMParser();
    svgs.forEach(svg => {
      // Fetch the file from the server.
      fetch(svg.src).then(response => response.text()).then(text => {
        // Turn the raw text into a document with the svg element in it.
        const parsed = parser.parseFromString(text, 'text/html'); // Select the <svg> element from that document.

        const svgTag = parsed.querySelector('svg'); // If the svg is found, replace the image with the svg.

        if (svgTag) svg.replaceWith(svgTag);
      });
    });
  };
  /**
   * Set variable for disableScrollLock.
   *
   * @param	{String}	elementId	Specific element ID.
   * @returns	{Boolean}				True if element is set, false if not.
   */

  const setTargetElement = elementId => {
    targetElement = document.querySelector(elementId);
    if (!targetElement) return false;
    return true;
  };
  /**
   * Get element for disableScrollLock.
   *
   * @returns targetElement value.
   */

  const getTargetElement = () => {
    return targetElement;
  };

  document.addEventListener('DOMContentLoaded', () => {

    renderSVGs(document);
    focusLabels();
    popupClose();
  });
  /**
   * Focus inputs inside specific labels.
   */

  const focusLabels = () => {
    const inputs = document.querySelectorAll('.label-focus input');
    if (!inputs.length) return;
    inputs.forEach(input => {
      const label = input.parentElement;
      if (!label) return;
      input.addEventListener('focus', () => {
        label.classList.add('focus');
      });
      input.addEventListener('blur', () => {
        label.classList.remove('focus');
      });
    });
  };
  /**
   * Close popup by clicking on close button.
   */


  const popupClose = () => {
    const popupCloseButtons = document.querySelectorAll('.popup-close');
    if (!popupCloseButtons.length) return;
    popupCloseButtons.forEach(button => {
      button.addEventListener('click', () => {
        const popup = button.closest('.popup');
        if (!popup) return;
        popup.classList.add('hidden');
        enableBodyScroll(getTargetElement());
      });
    });
  };

  document.addEventListener('DOMContentLoaded', () => {
    /**
     * @example of bodyScrollLock usage:
     *
    	let targetElement = document.querySelector( '#some-id' )	// Use ID of the element that will have normal scrolling behaviour.
    	disableBodyScroll( targetElement, { reserveScrollBarGap: true } )	// Disable main scroll.
    	enableBodyScroll( targetElement )	// Enable main scroll.
    */
  });

  document.addEventListener('DOMContentLoaded', () => {

    openSearchForm();
  });
  /**
   * Open search form popup.
   */

  const openSearchForm = () => {
    const buttons = document.querySelectorAll('.open-searchform'),
          popup = document.querySelector('#searchform-popup');
    if (!buttons.length || !popup) return;
    setTargetElement('#searchform-popup');
    buttons.forEach(button => {
      button.addEventListener('click', e => {
        e.preventDefault();
        popup.classList.remove('hidden');
        disableBodyScroll(getTargetElement(), {
          reserveScrollBarGap: true
        });
      });
    });
  };

})));

//# sourceMappingURL=main.min.js.map
