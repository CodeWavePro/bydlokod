(function (factory) {
  typeof define === 'function' && define.amd ? define('main', factory) :
  factory();
}((function () { 'use strict';

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  } // Older browsers don't support event options, feature detect it.
  // Adopted and modified solution from Bohdan Didukh (2017)
  // https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi


  var hasPassiveEvents = false;

  if (typeof window !== 'undefined') {
    var passiveTestOptions = {
      get passive() {
        hasPassiveEvents = true;
        return undefined;
      }

    };
    window.addEventListener('testPassive', null, passiveTestOptions);
    window.removeEventListener('testPassive', null, passiveTestOptions);
  }

  var isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);
  var locks = [];
  var documentListenerAdded = false;
  var initialClientY = -1;
  var previousBodyOverflowSetting = void 0;
  var previousBodyPaddingRight = void 0; // returns true if `el` should be allowed to receive touchmove events.

  var allowTouchMove = function allowTouchMove(el) {
    return locks.some(function (lock) {
      if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {
        return true;
      }

      return false;
    });
  };

  var preventDefault = function preventDefault(rawEvent) {
    var e = rawEvent || window.event; // For the case whereby consumers adds a touchmove event listener to document.
    // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })
    // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then
    // the touchmove event on document will break.

    if (allowTouchMove(e.target)) {
      return true;
    } // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).


    if (e.touches.length > 1) return true;
    if (e.preventDefault) e.preventDefault();
    return false;
  };

  var setOverflowHidden = function setOverflowHidden(options) {
    // If previousBodyPaddingRight is already set, don't set it again.
    if (previousBodyPaddingRight === undefined) {
      var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;

      var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;

      if (_reserveScrollBarGap && scrollBarGap > 0) {
        previousBodyPaddingRight = document.body.style.paddingRight;
        document.body.style.paddingRight = scrollBarGap + 'px';
      }
    } // If previousBodyOverflowSetting is already set, don't set it again.


    if (previousBodyOverflowSetting === undefined) {
      previousBodyOverflowSetting = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
    }
  };

  var restoreOverflowSetting = function restoreOverflowSetting() {
    if (previousBodyPaddingRight !== undefined) {
      document.body.style.paddingRight = previousBodyPaddingRight; // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it
      // can be set again.

      previousBodyPaddingRight = undefined;
    }

    if (previousBodyOverflowSetting !== undefined) {
      document.body.style.overflow = previousBodyOverflowSetting; // Restore previousBodyOverflowSetting to undefined
      // so setOverflowHidden knows it can be set again.

      previousBodyOverflowSetting = undefined;
    }
  }; // https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions


  var isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {
    return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;
  };

  var handleScroll = function handleScroll(event, targetElement) {
    var clientY = event.targetTouches[0].clientY - initialClientY;

    if (allowTouchMove(event.target)) {
      return false;
    }

    if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {
      // element is at the top of its scroll.
      return preventDefault(event);
    }

    if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {
      // element is at the bottom of its scroll.
      return preventDefault(event);
    }

    event.stopPropagation();
    return true;
  };

  var disableBodyScroll = function disableBodyScroll(targetElement, options) {
    // targetElement must be provided
    if (!targetElement) {
      // eslint-disable-next-line no-console
      console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');
      return;
    } // disableBodyScroll must not have been called on this targetElement before


    if (locks.some(function (lock) {
      return lock.targetElement === targetElement;
    })) {
      return;
    }

    var lock = {
      targetElement: targetElement,
      options: options || {}
    };
    locks = [].concat(_toConsumableArray(locks), [lock]);

    if (isIosDevice) {
      targetElement.ontouchstart = function (event) {
        if (event.targetTouches.length === 1) {
          // detect single touch.
          initialClientY = event.targetTouches[0].clientY;
        }
      };

      targetElement.ontouchmove = function (event) {
        if (event.targetTouches.length === 1) {
          // detect single touch.
          handleScroll(event, targetElement);
        }
      };

      if (!documentListenerAdded) {
        document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? {
          passive: false
        } : undefined);
        documentListenerAdded = true;
      }
    } else {
      setOverflowHidden(options);
    }
  };
  var enableBodyScroll = function enableBodyScroll(targetElement) {
    if (!targetElement) {
      // eslint-disable-next-line no-console
      console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');
      return;
    }

    locks = locks.filter(function (lock) {
      return lock.targetElement !== targetElement;
    });

    if (isIosDevice) {
      targetElement.ontouchstart = null;
      targetElement.ontouchmove = null;

      if (documentListenerAdded && locks.length === 0) {
        document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? {
          passive: false
        } : undefined);
        documentListenerAdded = false;
      }
    } else if (!locks.length) {
      restoreOverflowSetting();
    }
  };

  const ajaxUrl = window.wpData.ajaxUrl;
  let ajaxStatus = false,
      targetElement;
  /**
   * Render SVG code from images (<img /> tags).
   *
   * @param {DOMElement}	wrapper		DOM element, inside which need to render svgs.
   * @param {String}		imgSelector	Specific selector for <img /> tag to render SVG.
   */

  const renderSVGs = (wrapper, imgSelector = '') => {
    if (!wrapper) return; // Get images with specific selector only OR all images.

    const selector = imgSelector ? `img${imgSelector}` : 'img',
          images = wrapper.querySelectorAll(selector),
          svgs = []; // If there are no images - exit.

    if (!images.length) return; // Get only svg images to svgs array.

    images.forEach(img => {
      let src = img.src,
          extension = src.slice(-4);
      if (extension === '.svg') svgs.push(img);
    }); // If there are no svgs - exit.

    if (!svgs.length) return;
    const parser = new DOMParser();
    svgs.forEach(svg => {
      // Fetch the file from the server.
      fetch(svg.src).then(response => response.text()).then(text => {
        // Turn the raw text into a document with the svg element in it.
        const parsed = parser.parseFromString(text, 'text/html'); // Select the <svg> element from that document.

        const svgTag = parsed.querySelector('svg'); // If the svg is found, replace the image with the svg.

        if (svgTag) svg.replaceWith(svgTag);
      });
    });
  };
  /**
   * Set variable for disableScrollLock.
   *
   * @param	{String}	elementId	Specific element ID.
   * @returns	{Boolean}				True if element is set, false if not.
   */

  const setTargetElement = elementId => {
    targetElement = document.querySelector(elementId);
    if (!targetElement) return false;
    return true;
  };
  /**
   * Get element for disableScrollLock.
   *
   * @returns targetElement value.
   */

  const getTargetElement = () => {
    return targetElement;
  };
  /**
   * Get AJAX working status: is in work now or not.
   *
   * @returns	{Boolean} AJAX working status.
   */

  const getAjaxStatus = () => ajaxStatus;
  /**
   * Set AJAX working status: is in work now or not.
   *
   * @param	{Boolean}	state	Working status - true or false.
   * @returns	{Boolean}			True on success, false on failure.
   */

  const setAjaxStatus = state => {
    if (typeof state === 'boolean') ajaxStatus = state;else return false;
    return true;
  };
  /**
   * Custom AJAX request.
   *
   * @param	{Object}	formData	Data for fetch body.
   * @returns	{Array}					Reponse data array.
   */

  const bydloAjaxRequest = async formData => {
    let response = await fetch(ajaxUrl, {
      method: 'post',
      credentials: 'same-origin',
      body: formData
    });
    let data = await response.json();
    return data;
  };
  /**
   * Create loader HTML Object.
   *
   * @param	{String}		extraClass	Class for loader.
   * @returns {HTMLObject}	loader		HTML Object to insert in some block/element.
   */

  const createLoader = (extraClass = '') => {
    const loader = document.createElement('span');
    loader.classList.add('loader');
    loader.innerHTML = '<i class="fa-solid fa-circle-notch"></i>';
    if (extraClass) loader.classList.add(...extraClass.split(' '));
    return loader;
  };
  /**
   * Highlight invalid form fields.
   *
   * @param {Array}		errors	Array of invalid fields (IDs).
   * @param {HTMLObject}	form	In which forms these fields are placed.
   */

  const processFormErrors = (errors, form) => {
    if (!errors.length || !form) return;
    errors.forEach(fieldId => {
      const field = form.querySelector(`#${fieldId}`);
      if (!field) return;
      field.closest('label').classList.add('error');
    });
  };

  document.addEventListener('DOMContentLoaded', () => {

    renderSVGs(document);
    focusLabels();
    popupClose();
    popupCloseOnClick();
  });
  /**
   * Focus inputs inside specific labels.
   */

  const focusLabels = () => {
    const inputs = document.querySelectorAll('.label-focus input');
    if (!inputs.length) return;
    inputs.forEach(input => {
      const label = input.parentElement;
      input.addEventListener('focus', () => label.classList.add('focus'));
      input.addEventListener('blur', () => label.classList.remove('focus'));
    });
  };
  /**
   * Close popup by clicking on close button.
   */

  const popupClose = () => {
    const popupCloseButtons = document.querySelectorAll('.popup-close');
    if (!popupCloseButtons.length) return;
    popupCloseButtons.forEach(button => {
      button.addEventListener('click', () => {
        const popup = button.closest('.popup');
        if (!popup) return;
        popup.classList.add('hidden');
        enableBodyScroll(getTargetElement());
      });
    });
  };
  /**
   * Close popup if its area clicked.
   */


  const popupCloseOnClick = () => {
    const popups = document.querySelectorAll('.popup');
    if (!popups.length) return;
    popups.forEach(popup => {
      popup.addEventListener('click', e => {
        e.stopPropagation(); // If popup area clicked.

        if (e.target.classList.contains('popup')) {
          enableBodyScroll(getTargetElement());
          popup.classList.add('hidden');
        }
      });
    });
  };

  document.addEventListener('DOMContentLoaded', () => {
    /**
     * @example of bodyScrollLock usage:
     *
    	let targetElement = document.querySelector( '#some-id' )	// Use ID of the element that will have normal scrolling behaviour.
    	disableBodyScroll( targetElement, { reserveScrollBarGap: true } )	// Disable main scroll.
    	enableBodyScroll( targetElement )	// Enable main scroll.
    */
  });

  document.addEventListener('DOMContentLoaded', () => {

    openSearchForm();
  });
  /**
   * Open search form popup.
   */

  const openSearchForm = () => {
    const buttons = document.querySelectorAll('.open-searchform'),
          popup = document.querySelector('#searchform-popup');
    if (!buttons.length || !popup) return;
    setTargetElement('#searchform-popup');
    buttons.forEach(button => {
      button.addEventListener('click', e => {
        e.preventDefault();
        popup.classList.remove('hidden');
        disableBodyScroll(getTargetElement(), {
          reserveScrollBarGap: true
        });
      });
    });
  };

  /**
   * Clear some form's message element.
   *
   * @param {HTMLObject} msgElement	Form message element.
   */
  const clearFormMessage = msgElement => {
    if (!msgElement) return;
    msgElement.classList.remove('success');
    msgElement.innerHTML = '';
  };
  /**
   * Add success class to form's message element
   * and put success message content inside.
   *
   * @param {HTMLObject}	msgElement	Form message element.
   * @param {String}		msgContent	Message inner content.
   * @param {Boolean}		isSuccess	Is this success message or not.
   */

  const setFormMessage = (msgElement, msgContent, isSuccess = false) => {
    if (!msgElement || !msgContent) return;
    if (isSuccess) msgElement.classList.add('success');
    msgElement.innerHTML = msgContent;
  };
  /**
   * Remove error class from form's labels with it.
   *
   * @param {HTMLObject} form	Specific form.
   */

  const clearFormErrorClasses = form => {
    if (!form) return;
    form.querySelectorAll('label.error').forEach(label => label.classList.remove('error'));
  };

  document.addEventListener('DOMContentLoaded', () => {

    openAuthPopup();
    logout();
  });
  /**
   * Open authorization popup with Login or Register form.
   */

  const openAuthPopup = () => {
    const authLinks = document.querySelectorAll('.header-auth-link'),
          authPopup = document.querySelector('.popup-auth');
    if (!authLinks.length || !authPopup) return;
    const popupInner = authPopup.querySelector('.popup-inner');
    authLinks.forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        if (getAjaxStatus()) return;
        setAjaxStatus(true);
        const ajaxData = new FormData(),
              loader = createLoader('centered lg violet');
        let type = link.classList.contains('login') ? 'login' : 'register';
        ajaxData.append('action', 'bydlo_ajax_show_auth_form');
        ajaxData.append('type', type); // Show popup with loader.

        setTargetElement('#popup-auth');
        disableBodyScroll(getTargetElement(), {
          reserveScrollBarGap: true
        });
        popupInner.innerHTML = '';
        popupInner.appendChild(loader);
        authPopup.classList.remove('hidden');
        bydloAjaxRequest(ajaxData).then(response => {
          if (response) {
            loader.remove();

            switch (response.success) {
              case true:
                popupInner.innerHTML = response.data.form;
                focusLabels();
                if (type === 'login') login();else register();
                openAnotherFormInsidePopup();
                break;

              case false:
                popupInner.innerHTML = response.data.msg;
                break;
            }
          }

          setAjaxStatus(false);
        });
      });
    });
  };
  /**
   * Open another form inside authorization popup on links click.
   */


  const openAnotherFormInsidePopup = () => {
    const authLinks = document.querySelectorAll('.form-link'),
          authPopup = document.querySelector('.popup-auth');
    if (!authLinks.length || !authPopup) return;
    const popupInner = authPopup.querySelector('.popup-inner');
    authLinks.forEach(link => {
      link.addEventListener('click', e => {
        e.preventDefault();
        if (getAjaxStatus()) return;
        setAjaxStatus(true);
        const ajaxData = new FormData(),
              loader = createLoader('centered lg violet');
        let type = link.classList.contains('login') ? 'login' : 'register';
        ajaxData.append('action', 'bydlo_ajax_show_auth_form');
        ajaxData.append('type', type); // Show popup with loader.

        setTargetElement('#popup-auth');
        disableBodyScroll(getTargetElement(), {
          reserveScrollBarGap: true
        });
        popupInner.innerHTML = '';
        popupInner.appendChild(loader);
        bydloAjaxRequest(ajaxData).then(response => {
          if (response) {
            loader.remove();

            switch (response.success) {
              case true:
                popupInner.innerHTML = response.data.form;
                focusLabels();
                type === 'login' ? login() : null;
                openAnotherFormInsidePopup();
                break;

              case false:
                popupInner.innerHTML = response.data.msg;
                break;
            }
          }

          setAjaxStatus(false);
        });
      });
    });
  };
  /**
   * Login.
   */

  const login = () => {
    const form = document.querySelector('.form-login');
    if (!form) return;
    form.addEventListener('submit', e => {
      e.preventDefault();
      if (getAjaxStatus()) return;
      setAjaxStatus(true);
      const formData = new FormData(form),
            button = form.querySelector('.button[type="submit"]'),
            msg = form.querySelector('.form-message'),
            loader = createLoader();
      formData.append('action', 'bydlo_ajax_login');
      formData.append('form_data', formData);
      button.appendChild(loader);
      clearFormMessage(msg);
      clearFormErrorClasses(form);
      bydloAjaxRequest(formData).then(response => {
        if (response) {
          loader.remove();

          switch (response.success) {
            case true:
              setFormMessage(msg, response.data.msg, true);
              if (response.data.redirect) location.href = response.data.redirect;
              break;

            case false:
              console.error(response.data.msg);
              setFormMessage(msg, response.data.msg); // If has errors.

              if (response.data.errors && response.data.errors.length) processFormErrors(JSON.parse(response.data.errors), form);
              break;
          }
        }

        setAjaxStatus(false);
      });
    });
  };
  /**
   * Logout.
   */

  const logout = () => {
    const link = document.querySelector('.header-logout-link');
    if (!link) return;
    link.addEventListener('click', e => {
      e.preventDefault();
      if (getAjaxStatus()) return;
      setAjaxStatus(true);
      const formData = new FormData(),
            loader = createLoader();
      formData.append('action', 'bydlo_ajax_logout');
      link.appendChild(loader);
      bydloAjaxRequest(formData).then(response => {
        if (response) {
          loader.remove();

          switch (response.success) {
            case true:
              console.log(response.data.msg);
              if (response.data.redirect) location.href = response.data.redirect;
              break;

            case false:
              console.error(response.data.msg);
              break;
          }
        }

        setAjaxStatus(false);
      });
    });
  };
  /**
   * Registration.
   */


  const register = () => {
    const form = document.querySelector('.form-register');
    if (!form) return;
    form.addEventListener('submit', e => {
      e.preventDefault();
      if (getAjaxStatus()) return;
      setAjaxStatus(true);
      const formData = new FormData(form),
            button = form.querySelector('.button[type="submit"]'),
            msg = form.querySelector('.form-message'),
            loader = createLoader();
      formData.append('action', 'bydlo_ajax_register');
      formData.append('form_data', formData);
      button.appendChild(loader);
      clearFormMessage(msg);
      clearFormErrorClasses(form);
      bydloAjaxRequest(formData).then(response => {
        if (response) {
          loader.remove();

          switch (response.success) {
            case true:
              setFormMessage(msg, response.data.msg, true);
              break;

            case false:
              console.error(response.data.msg);
              setFormMessage(msg, response.data.msg); // If has errors.

              if (response.data.errors && response.data.errors.length) processFormErrors(JSON.parse(response.data.errors), form);
              break;
          }
        }

        setAjaxStatus(false);
      });
    });
  };

  document.addEventListener('DOMContentLoaded', () => {

    loadMorePosts();
    clickPostLike();
  });
  /**
   * Load more posts on button click.
   */

  const loadMorePosts = () => {
    const posts = document.querySelectorAll('.post-preview'),
          postsWrapper = document.querySelector('.main-posts'),
          button = document.querySelector('.posts-loadmore .button');
    if (!posts.length || !button || !postsWrapper) return;
    button.addEventListener('click', () => {
      if (getAjaxStatus()) return;
      setAjaxStatus(true);
      const ajaxData = new FormData(),
            loader = createLoader(),
            perPage = parseInt(button.dataset.perPage),
            totalCount = parseInt(button.dataset.allPostsCount);
      let offset = parseInt(button.dataset.offset);
      ajaxData.append('action', 'bydlo_ajax_load_more_posts');
      ajaxData.append('per_page', perPage);
      ajaxData.append('offset', offset);
      button.appendChild(loader);
      bydloAjaxRequest(ajaxData).then(response => {
        if (response) {
          loader.remove();

          switch (response.success) {
            case true:
              console.log(response.data.msg);
              postsWrapper.innerHTML += response.data.posts;
              clickPostLike(); // If there are no more posts - remove button.

              if (totalCount <= offset + perPage) button.remove();else button.dataset.offset = offset + perPage;
              break;

            case false:
              console.error(response.data.msg);
              break;
          }
        }

        setAjaxStatus(false);
      });
    });
  };
  /**
   * Click on post's likes block.
   */


  const clickPostLike = () => {
    const likesBlocks = document.querySelectorAll('.post-stats-item.reactions');
    if (!likesBlocks.length) return;
    likesBlocks.forEach(likesBlock => {
      const postId = likesBlock.dataset.post;
      let likesCount = likesBlock.querySelector('span'),
          icon = likesBlock.querySelector('i');
      if (!postId) return;
      likesBlock.addEventListener('click', () => {
        if (getAjaxStatus()) return;
        setAjaxStatus(true);
        const ajaxData = new FormData(),
              loader = createLoader();
        ajaxData.append('action', 'bydlo_ajax_set_post_likes');
        ajaxData.append('post_id', postId);
        likesBlock.appendChild(loader);
        bydloAjaxRequest(ajaxData).then(response => {
          if (response) {
            loader.remove();

            switch (response.success) {
              case true:
                console.log(response.data.msg); // If it was like.

                if (response.data.like) {
                  icon.classList.add('like-animation');
                  likesBlock.setAttribute('title', 'Вам понравилось');
                  setTimeout(() => {
                    icon.classList.remove('like-animation');
                    likesBlock.classList.add('you-liked');
                    likesCount.innerHTML = response.data.count;
                  }, 750);
                } else {
                  // If it was dislike.
                  icon.classList.add('dislike-animation');
                  likesBlock.setAttribute('title', 'Оценить');
                  setTimeout(() => {
                    icon.classList.remove('dislike-animation');
                    likesBlock.classList.remove('you-liked');
                    likesCount.innerHTML = response.data.count;
                  }, 750);
                }

                break;

              case false:
                console.error(response.data.msg); // If User is not logged in - show Login form in popup.

                if (response.data.form) {
                  const authPopup = document.querySelector('.popup-auth');
                  if (!authPopup) break;
                  const popupInner = authPopup.querySelector('.popup-inner');
                  setTargetElement('#popup-auth');
                  disableBodyScroll(getTargetElement(), {
                    reserveScrollBarGap: true
                  });
                  popupInner.innerHTML = response.data.form;
                  authPopup.classList.remove('hidden');
                  focusLabels();
                  login();
                  openAnotherFormInsidePopup();
                }

                break;
            }
          }

          setAjaxStatus(false);
        });
      });
    });
  };

})));

//# sourceMappingURL=main.min.js.map
