{"version":3,"sources":["src/js/common/global.js","src/js/common/common.js","node_modules/body-scroll-lock/lib/bodyScrollLock.esm.js","src/js/common/header.js"],"names":["renderSVGs","wrapper","imgSelector","selector","images","querySelectorAll","svgs","length","forEach","img","src","extension","slice","push","parser","DOMParser","svg","fetch","then","response","text","parsed","parseFromString","svgTag","querySelector","replaceWith","document","addEventListener","window","passiveTestOptions","passive","undefined","removeEventListener","isIosDevice","navigator","platform","test","maxTouchPoints"],"mappings":";;;;;CAAA;CACA;CACA;CACA;CACA;CACA;CACO,MAAMA,UAAU,GAAG,CAAEC,OAAF,EAAWC,WAAW,GAAG,EAAzB,KAAiC;GAC1D,IAAI,CAAED,OAAN,EAAgB,OAD0C;;GAI1D,MAAME,QAAQ,GAAGD,WAAW,GAAI,MAAKA,WAAY,EAArB,GAAyB,KAArD;SACCE,MAAM,GAAIH,OAAO,CAACI,gBAAR,CAA0BF,QAA1B,CADX;SAECG,IAAI,GAAI,EAFT,CAJ0D;;GAS1D,IAAI,CAAEF,MAAM,CAACG,MAAb,EAAsB,OAToC;;GAY1DH,MAAM,CAACI,OAAP,CAAgBC,GAAG,IAAI;KACtB,IAAIC,GAAG,GAAKD,GAAG,CAACC,GAAhB;SACCC,SAAS,GAAGD,GAAG,CAACE,KAAJ,CAAW,CAAC,CAAZ,CADb;KAGA,IAAID,SAAS,KAAK,MAAlB,EAA2BL,IAAI,CAACO,IAAL,CAAWJ,GAAX;IAJ5B,EAZ0D;;GAoB1D,IAAI,CAAEH,IAAI,CAACC,MAAX,EAAoB;GAEpB,MAAMO,MAAM,GAAG,IAAIC,SAAJ,EAAf;GAEAT,IAAI,CAACE,OAAL,CAAcQ,GAAG,IAAI;;KAEpBC,KAAK,CAAED,GAAG,CAACN,GAAN,CAAL,CACEQ,IADF,CACQC,QAAQ,IAAIA,QAAQ,CAACC,IAAT,EADpB,EAEEF,IAFF,CAEQE,IAAI,IAAI;;OAEd,MAAMC,MAAM,GAAGP,MAAM,CAACQ,eAAP,CAAwBF,IAAxB,EAA8B,WAA9B,CAAf,CAFc;;OAId,MAAMG,MAAM,GAAGF,MAAM,CAACG,aAAP,CAAsB,KAAtB,CAAf,CAJc;;OAOd,IAAID,MAAJ,EAAaP,GAAG,CAACS,WAAJ,CAAiBF,MAAjB;MATf;IAFD;CAcA,CAtCM;;CCJPG,QAAQ,CAACC,gBAAT,CAA2B,kBAA3B,EAA+C,MAAM;;GAGpD3B,UAAU,CAAE0B,QAAF,CAAV;CACA,CAJD;;CCMA,IAAI,OAAOE,MAAP,KAAkB,WAAtB,EAAmC;GACjC,IAAIC,kBAAkB,GAAG;KACvB,IAAIC,OAAJ,GAAc;OAEZ,OAAOC,SAAP;;;IAHJ;GAMAH,MAAM,CAACD,gBAAP,CAAwB,aAAxB,EAAuC,IAAvC,EAA6CE,kBAA7C;GACAD,MAAM,CAACI,mBAAP,CAA2B,aAA3B,EAA0C,IAA1C,EAAgDH,kBAAhD;CACD;;CAED,IAAII,WAAW,GAAG,OAAOL,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACM,SAAxC,IAAqDN,MAAM,CAACM,SAAP,CAAiBC,QAAtE,KAAmF,iBAAiBC,IAAjB,CAAsBR,MAAM,CAACM,SAAP,CAAiBC,QAAvC,KAAoDP,MAAM,CAACM,SAAP,CAAiBC,QAAjB,KAA8B,UAA9B,IAA4CP,MAAM,CAACM,SAAP,CAAiBG,cAAjB,GAAkC,CAArN,CAAlB;;CCjBAX,QAAQ,CAACC,gBAAT,CAA2B,kBAA3B,EAA+C,MAAM;;CAIrD;CACA;CACA;CACA;CACA;CACA;CACC,CAVD","file":"main.min.js","sourcesContent":["/**\r\n * Render SVG code from images (<img /> tags).\r\n *\r\n * @param {DOMElement}\twrapper\t\tDOM element, inside which need to render svgs.\r\n * @param {String}\t\timgSelector\tSpecific selector for <img /> tag to render SVG.\r\n */\r\nexport const renderSVGs = ( wrapper, imgSelector = '' ) => {\r\n\tif( ! wrapper ) return\r\n\r\n\t// Get images with specific selector only OR all images.\r\n\tconst selector\t= imgSelector ? `img${imgSelector}` : 'img',\r\n\t\timages\t\t= wrapper.querySelectorAll( selector ),\r\n\t\tsvgs\t\t= []\r\n\r\n\t// If there are no images - exit.\r\n\tif( ! images.length ) return\r\n\r\n\t// Get only svg images to svgs array.\r\n\timages.forEach( img => {\r\n\t\tlet src\t\t\t= img.src,\r\n\t\t\textension\t= src.slice( -4 )\r\n\r\n\t\tif( extension === '.svg' ) svgs.push( img )\r\n\t} )\r\n\r\n\t// If there are no svgs - exit.\r\n\tif( ! svgs.length ) return\r\n\r\n\tconst parser = new DOMParser()\r\n\r\n\tsvgs.forEach( svg => {\r\n\t\t// Fetch the file from the server.\r\n\t\tfetch( svg.src )\r\n\t\t\t.then( response => response.text() )\r\n\t\t\t.then( text => {\r\n\t\t\t\t// Turn the raw text into a document with the svg element in it.\r\n\t\t\t\tconst parsed = parser.parseFromString( text, 'text/html' )\r\n\t\t\t\t// Select the <svg> element from that document.\r\n\t\t\t\tconst svgTag = parsed.querySelector( 'svg' )\r\n\r\n\t\t\t\t// If the svg is found, replace the image with the svg.\r\n\t\t\t\tif( svgTag ) svg.replaceWith( svgTag )\r\n\t\t\t} )\r\n\t} )\r\n}","import { renderSVGs } from './global'\r\n\r\ndocument.addEventListener( 'DOMContentLoaded', () => {\r\n\t'use strict'\r\n\r\n\trenderSVGs( document )\r\n} )","function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n// Older browsers don't support event options, feature detect it.\n\n// Adopted and modified solution from Bohdan Didukh (2017)\n// https://stackoverflow.com/questions/41594997/ios-10-safari-prevent-scrolling-behind-a-fixed-overlay-and-maintain-scroll-posi\n\nvar hasPassiveEvents = false;\nif (typeof window !== 'undefined') {\n  var passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true;\n      return undefined;\n    }\n  };\n  window.addEventListener('testPassive', null, passiveTestOptions);\n  window.removeEventListener('testPassive', null, passiveTestOptions);\n}\n\nvar isIosDevice = typeof window !== 'undefined' && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1);\n\n\nvar locks = [];\nvar documentListenerAdded = false;\nvar initialClientY = -1;\nvar previousBodyOverflowSetting = void 0;\nvar previousBodyPaddingRight = void 0;\n\n// returns true if `el` should be allowed to receive touchmove events.\nvar allowTouchMove = function allowTouchMove(el) {\n  return locks.some(function (lock) {\n    if (lock.options.allowTouchMove && lock.options.allowTouchMove(el)) {\n      return true;\n    }\n\n    return false;\n  });\n};\n\nvar preventDefault = function preventDefault(rawEvent) {\n  var e = rawEvent || window.event;\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true;\n  }\n\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true;\n\n  if (e.preventDefault) e.preventDefault();\n\n  return false;\n};\n\nvar setOverflowHidden = function setOverflowHidden(options) {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    var _reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;\n    var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;\n\n    if (_reserveScrollBarGap && scrollBarGap > 0) {\n      previousBodyPaddingRight = document.body.style.paddingRight;\n      document.body.style.paddingRight = scrollBarGap + 'px';\n    }\n  }\n\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n  }\n};\n\nvar restoreOverflowSetting = function restoreOverflowSetting() {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight;\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined;\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting;\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined;\n  }\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nvar isTargetElementTotallyScrolled = function isTargetElementTotallyScrolled(targetElement) {\n  return targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false;\n};\n\nvar handleScroll = function handleScroll(event, targetElement) {\n  var clientY = event.targetTouches[0].clientY - initialClientY;\n\n  if (allowTouchMove(event.target)) {\n    return false;\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event);\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event);\n  }\n\n  event.stopPropagation();\n  return true;\n};\n\nexport var disableBodyScroll = function disableBodyScroll(targetElement, options) {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error('disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.');\n    return;\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(function (lock) {\n    return lock.targetElement === targetElement;\n  })) {\n    return;\n  }\n\n  var lock = {\n    targetElement: targetElement,\n    options: options || {}\n  };\n\n  locks = [].concat(_toConsumableArray(locks), [lock]);\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = function (event) {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY;\n      }\n    };\n    targetElement.ontouchmove = function (event) {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement);\n      }\n    };\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);\n      documentListenerAdded = true;\n    }\n  } else {\n    setOverflowHidden(options);\n  }\n};\n\nexport var clearAllBodyScrollLocks = function clearAllBodyScrollLocks() {\n  if (isIosDevice) {\n    // Clear all locks ontouchstart/ontouchmove handlers, and the references.\n    locks.forEach(function (lock) {\n      lock.targetElement.ontouchstart = null;\n      lock.targetElement.ontouchmove = null;\n    });\n\n    if (documentListenerAdded) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);\n      documentListenerAdded = false;\n    }\n\n    // Reset initial clientY.\n    initialClientY = -1;\n  } else {\n    restoreOverflowSetting();\n  }\n\n  locks = [];\n};\n\nexport var enableBodyScroll = function enableBodyScroll(targetElement) {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error('enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.');\n    return;\n  }\n\n  locks = locks.filter(function (lock) {\n    return lock.targetElement !== targetElement;\n  });\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null;\n    targetElement.ontouchmove = null;\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined);\n      documentListenerAdded = false;\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting();\n  }\n};\n\n","import { disableBodyScroll, enableBodyScroll } from 'body-scroll-lock'\r\n\r\ndocument.addEventListener( 'DOMContentLoaded', () => {\r\n\t'use strict'\r\n\r\n\t/**\r\n\t * @example of bodyScrollLock usage:\r\n\t *\r\n\t\tlet targetElement = document.querySelector( '#some-id' )\t// Use ID of the element that will have normal scrolling behaviour.\r\n\t\tdisableBodyScroll( targetElement, { reserveScrollBarGap: true } )\t// Disable main scroll.\r\n\t\tenableBodyScroll( targetElement )\t// Enable main scroll.\r\n\t*/\r\n} )"]}